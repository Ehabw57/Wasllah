<!doctype html>
<html>
  <head>
    <title>wassla</title>
  </head>
  <body>
    <h1>connected Devices:</h1>
    <div id="devices"></div>
    <input type="file" id="fileInput" />
    <script>
      const fileInput = document.getElementById("fileInput");
      fileInput.onchange = (event) => {
        const file = event.target.files[0];
        if (file) {
          sendFile(file);
        }
      };
      const socket = new WebSocket("ws://localhost:3000");
      const devicesDiv = document.getElementById("devices");
      const pc = new RTCPeerConnection();
      let fileMeta = null;
      let receivedBuffers = [];
      let receivedSize = 0;

      let dataChannel = null;

      function waitForBuffer() {
        return new Promise((resolve) => {
          dataChannel.onbufferedamountlow = resolve;
        });
      }

      function download(blob, filename) {
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.click();
      }

      function onMessage(event) {
        if (typeof event.data === "string") {
          const msg = JSON.parse(event.data);

          if (msg.type === "meta") {
            fileMeta = msg;
            receivedBuffers = [];
            receivedSize = 0;
          }

          if (msg.type === "end") {
            const blob = new Blob(receivedBuffers);
            download(blob, fileMeta.name);
          }

          return;
        }

        receivedBuffers.push(event.data);
        receivedSize += event.data.byteLength;

        console.log(`Received ${(receivedSize/fileMeta.size * 100).toFixed(2)}%`);
      }

      async function sendFile(file) {
        if (dataChannel && dataChannel.readyState === "open") {
          dataChannel.binaryType = "arraybuffer";
          dataChannel.send(
            JSON.stringify({
              type: "meta",
              id: Date.now(),
              name: file.name,
              size: file.size,
            }),
          );
          let offset = 0;
          buffer = await file.arrayBuffer();
          while (offset < buffer.byteLength) {
            if (dataChannel.bufferedAmount > 16 * 1024) {
              console.log(`Sending ${(offset / buffer.byteLength * 100).toFixed(2)}%`);
              await waitForBuffer();
            }
            const chunk = buffer.slice(offset, offset + 16 * 1024);
            dataChannel.send(chunk);
            offset += 16 * 1024;
          }
          dataChannel.send(JSON.stringify({ type: "end" }));
        } else {
          console.log("Data channel is not open");
        }
      }
      pc.onconnectionstatechange = () => {
        console.log("Connection state:", pc.connectionState);
      };

      // Handle incoming data channels (answers side)
      pc.ondatachannel = (event) => {
        dataChannel = event.channel;
        dataChannel.onopen = () => console.log("Data channel opened");
        dataChannel.onmessage = onMessage;
      };

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          socket.send(
            JSON.stringify({
              type: "ice-candidate",
              candidate: event.candidate,
              targetId: pc.peerId,
            }),
          );
        }
      };

      function sendData(data) {
        console.log("Sending data:", data);
        if (dataChannel && dataChannel.readyState === "open") {
          dataChannel.send(data);
        } else {
          console.log("Data channel is not open");
        }
      }

      async function sendOffer(targetId) {
        pc.peerId = targetId;

        dataChannel = pc.createDataChannel("data");
        dataChannel.onopen = () => console.log("Data channel open");
        dataChannel.onmessage = onMessage;
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        socket.send(
          JSON.stringify({
            type: "offer",
            offer: pc.localDescription,
            targetId,
          }),
        );
      }

      socket.onopen = () => {
        console.log("Connected to server");
        const name = navigator.platform;
        socket.send(JSON.stringify({ type: "auth", name }));
      };

      socket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        if (data.type === "connectedClients") {
          data.clients.forEach((client) => {
            const content = `<div>${client.name}:${client.origin}<button onclick="sendOffer('${client.id}')">Connect</button><button onclick="sendData('${client.id}')">Send Data</button></div>`;
            const device = document.createElement("div");
            device.id = client.id;
            device.innerHTML = content;
            devicesDiv.appendChild(device);
          });
        }
        if (data.type === "connection") {
          const device = document.createElement("div");
          device.id = data.id;
          const content = `<div>${data.name}:${data.origin}<button onclick="sendOffer('${data.id}')">Connect</button><button onclick="sendData('${data.id}')">Send Data</button></div>`;
          device.innerHTML = content;
          devicesDiv.appendChild(device);
        }

        if (data.type === "disconnection") {
          const device = document.getElementById(data.id);
          console.log(`Device disconnected: ID ${data.id}`);
          if (device) {
            devicesDiv.removeChild(device);
          }
        }
        if (data.type === "offer") {
          pc.peerId = data.from;
          pc.setRemoteDescription(data.offer);
          pc.createAnswer().then((answer) => {
            pc.setLocalDescription(answer);
            socket.send(
              JSON.stringify({ type: "answer", answer, targetId: data.from }),
            );
          });
        }

        if (data.type === "answer") {
          pc.peerId = data.from;
          pc.setRemoteDescription(data.answer);
        }

        if (data.type === "ice-candidate") {
          pc.addIceCandidate(data.candidate);
        }
      };
    </script>
  </body>
</html>
